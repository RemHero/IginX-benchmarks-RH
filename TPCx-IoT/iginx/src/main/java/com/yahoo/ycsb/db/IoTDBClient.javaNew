package com.yahoo.ycsb.db;

import static cn.edu.tsinghua.iginx.thrift.DataType.BINARY;

import cn.edu.tsinghua.iginx.exceptions.ExecutionException;
import cn.edu.tsinghua.iginx.exceptions.SessionException;
import cn.edu.tsinghua.iginx.session.Session;
import cn.edu.tsinghua.iginx.session.SessionQueryDataSet;
import cn.edu.tsinghua.iginx.thrift.DataType;
import com.yahoo.ycsb.ByteArrayByteIterator;
import com.yahoo.ycsb.ByteIterator;
import com.yahoo.ycsb.DB;
import com.yahoo.ycsb.DBException;
import com.yahoo.ycsb.Status;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Vector;
import java.util.stream.Collectors;

public class IoTDBClient extends DB {

  private Session session = null;

  private final static Object SESSION_LOCK = new Object();
  private final static Object CACHE_LOCK = new Object();

  private Map<Long, Map<String, byte[]>> cacheData;
  private static int cacheNum = 0;
  private static String measurement;

  private String db_host = "localhost";
  private int db_port = 2333;
  private int cache_threshold = 5000;
  private boolean debug = true;

/*  private static final BigInteger SG_NUM = BigInteger.valueOf(50);
  private static final String sgPrefix = "sg";
  private static String getSgName(String deviceID){
    byte[] bytes = new byte[0];
    int modValue = 0;
    try {
      bytes = deviceID.getBytes("utf-8");
      MessageDigest digest = MessageDigest.getInstance("MD4");
      BigInteger bi = new BigInteger(digest.digest(bytes));
      modValue = bi.mod(SG_NUM).intValue();
    } catch (UnsupportedEncodingException e) {
      e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
    return sgPrefix+modValue;
  }*/

  public void init() throws DBException {
    if ((getProperties().getProperty("debug") != null)
        && (getProperties().getProperty("debug").compareTo("true") == 0)) {
      debug = true;
    }
    if (getProperties().containsKey("iotdbinfo")) {
      String[] serverInfo = getProperties().getProperty("iotdbinfo").split(":");
      if (serverInfo.length != 3) {
        System.err.println("Parse IoTDB Server info failed,it should be ip:port:threshold");
      } else {
        this.db_host = serverInfo[0];
        this.db_port = Integer.parseInt(serverInfo[1]);
        this.cache_threshold = Integer.parseInt(serverInfo[2]);
        if (debug) {
          System.out
              .printf("Parse IoTDB Server info succeed: %s:%d:%d%n", db_host, db_port,
                  cache_threshold);
        }
      }
    }
    synchronized (CACHE_LOCK) {
      if (cacheData == null) {
        cacheData = new HashMap<>();
      }
    }
    try {
      session = new Session(db_host, db_port);
      session.openSession();
      System.err.printf("start session(%s:%s) succeed%n", db_host, db_port);
    } catch (SessionException e) {
      System.err.printf("start session(%s:%s) failed:%s%n", db_host, db_port, e.toString());
      e.printStackTrace();
      throw new DBException(e);
    }
  }

  public void cleanup() throws DBException {
      try {
        synchronized (CACHE_LOCK) {
          if (cacheNum > 0) {
            insertRecords(cacheData);
            cacheData.clear();
          }
        }
        session.closeSession();
        session = null;
        if (debug) {
          System.out.printf("cleanup session(%s:%s) succeed%n", db_host, db_port);
        }
      } catch (SessionException | ExecutionException e) {
        System.err.printf("cleanup session(%s:%s) failed:%s%n", db_host, db_port, e.toString());
        e.printStackTrace();
        throw new DBException(e);
      }
  }

  // TPCx-IoT will not use this method
  public Status read(String table, String key, Set<String> fields,
      HashMap<String, ByteIterator> result) {
    return Status.OK;
  }

  // TPCx-IoT will not use this method
  public Status scan(String table, String startkey, int recordcount, Set<String> fields,
      Vector<HashMap<String, ByteIterator>> result) {
    return Status.OK;
  }

  public Status scan(String table, String filter, String clientFilter, String timestamp,
      Set<String> fields, long runStartTime, Vector<HashMap<String, ByteIterator>> result1,
      Vector<HashMap<String, ByteIterator>> result2) {
    String deviceID = String.format("%s.%s", clientFilter, filter);
    long newTimeStamp = Long.parseLong(timestamp);
    long oldTimeStamp;
    Status s1 = null;
    try {
      s1 = scanHelper(deviceID, newTimeStamp, fields, result1);
    } catch (ExecutionException e) {
      e.printStackTrace();
    }
    if (runStartTime > 0L) {
      long time = newTimeStamp - runStartTime;
      oldTimeStamp = newTimeStamp - time;
    } else {
      oldTimeStamp = newTimeStamp - 1800000L;
    }
    long timestampVal =
        oldTimeStamp + (long) (Math.random() * (newTimeStamp - 10000L - oldTimeStamp));
    Status s2 = null;
    try {
      s2 = scanHelper(deviceID, timestampVal, fields, result2);
    } catch (ExecutionException e) {
      e.printStackTrace();
    }
    if (s1.isOk() && s2.isOk()) {
      return Status.OK;
    }
    return Status.ERROR;
  }

  private Status scanHelper(String deviceID, long timestamp, Set<String> fields,
      Vector<HashMap<String, ByteIterator>> result)
      throws ExecutionException {
    long startTime = timestamp;
    long endTime = timestamp + 5000L;
    List<String> paths = Collections.singletonList(deviceID + ".field0");
    try {
      SessionQueryDataSet dataSet;
      synchronized (SESSION_LOCK) {
        dataSet = session.queryData(paths, startTime, endTime);
      }
      for (int i = 0; i < dataSet.getTimestamps().length; i++) {
        HashMap<String, ByteIterator> rowResult = new HashMap<>();
        if (dataSet.getPaths().size() != 0) {
          rowResult.put("field0", new ByteArrayByteIterator((byte[]) dataSet.getValues().get(i).get(0)));
          result.add(rowResult);
        }
      }
    } catch (SessionException e) {
      e.printStackTrace();
      return Status.ERROR;
    }
    return Status.OK;
  }

  private String transferLongToDate(Long millSec) {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date date = new Date(millSec);
    return sdf.format(date);
  }

  // TPCx-IoT will not use this method
  public Status update(String table, String key, HashMap<String, ByteIterator> values) {
    return Status.OK;
  }

  // only support one sensor now
  public Status insert(String table, String key, HashMap<String, ByteIterator> values) {
    String[] params = key.split(":");
    String deviceID = String.format("%s.%s",params[0], params[1]);
    long timestamp = Long.parseLong(params[2]);

    try {
      Map<Long, Map<String, byte[]>> previousCachedData = null;
      if (measurement == null) {
        measurement = values.keySet().iterator().next();
      }
      byte[] cValue = values.values().iterator().next().toArray();
      synchronized (CACHE_LOCK) {
        cacheData.computeIfAbsent(timestamp, k -> new HashMap<>()).put(deviceID, cValue);
        cacheNum++;
        if (cacheNum >= cache_threshold) {
          previousCachedData = cacheData;
          cacheNum = 0;
          cacheData = new HashMap<>();
        }
      }
      if (previousCachedData != null) {
        insertRecords(previousCachedData);
      }
    } catch (SessionException | ExecutionException e) {
      e.printStackTrace();
      System.err
          .printf("write %d records to server failed because %s%n", cache_threshold, e.toString());
      return Status.ERROR;
    }
    return Status.OK;
  }

  private void insertRecords(Map<Long, Map<String, byte[]>> cacheData)
      throws SessionException, ExecutionException {
    List<String> prefixList = cacheData.values().stream().map(Map::keySet)
        .flatMap(Collection::stream).distinct().collect(Collectors.toList());
    List<String> paths = new ArrayList<>();
    List<DataType> dataTypeList = new ArrayList<>();
    for (String prefix : prefixList) {
      paths.add(prefix + "." + measurement);
      dataTypeList.add(BINARY);
    }
    long[] timestamps = new long[cacheData.size()];
    Object[] valuesList = new Object[cacheData.size()];
    int index = 0;
    for (Entry<Long, Map<String, byte[]>> entry : cacheData.entrySet()) {
      timestamps[index] = entry.getKey();
      Map<String, byte[]> fieldMap = entry.getValue();
      Object[] values = new Object[paths.size()];
      for (int i = 0; i < prefixList.size(); i++) {
        String prefix = prefixList.get(i);
        values[i] = fieldMap.get(prefix);
      }
      valuesList[index] = values;
      index++;
    }
    session.insertRowRecords(paths, timestamps, valuesList, dataTypeList, null);
  }

  // TPCx-IoT will not use this method
  public Status delete(String table, String key) {
    return Status.OK;
  }
}
